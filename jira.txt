// extension.ts
import * as vscode from "vscode";
import fetch from "node-fetch";
import * as path from "path";
import * as fs from "fs";
import {
  getUserContext,
  updateUserContext,
  clearUserContext,
  formatUserContextMarkdown,
} from "./context";

const BASE_PROMPT =
  "You are a helpful Jira assistant. You can retrieve, comment on, update, and create Jira issues. Be concise and return markdown-formatted responses.";

let currentIssueKey: string | null = null;
const output = vscode.window.createOutputChannel("Jira Extension Logs");

export function activate(context: vscode.ExtensionContext) {
  const handler: vscode.ChatRequestHandler = async (
    request,
    chatContext,
    stream,
    token
  ) => {
    const config = vscode.workspace.getConfiguration();
    const domain = config.get<string>("jiraChat.domain");
    const email = config.get<string>("jiraChat.email");
    const apiToken = config.get<string>("jiraChat.apiToken");

    if (!domain || !email || !apiToken) {
      stream.markdown("‚ùå Please configure Jira credentials in settings (`jiraChat.*`).");
      return;
    }

    const userInput = request.prompt.trim();
    const parts = userInput.split(" ").map((p) => p.trim());
    const firstWord = parts[0]?.toLowerCase();

    // Enforce set-context before other commands
    const userContext = getUserContext(context);
    if (!firstWord.startsWith("set-context") && !userContext?.issueKey) {
      stream.markdown("‚ùó Please set context first using `set-context [story|defect] <ISSUE-KEY>`.");
      return;
    }

    if (firstWord === "set-context") {
      const [_, type, ...rest] = parts;
      const value = rest.join(" ").trim().toUpperCase();
      if (!type || !value) {
        stream.markdown("‚ùó Usage: `set-context [project|story|defect|sprint|backlog] <value>`");
        return;
      }

      const success = await updateUserContext(context, {
        projectKey: type === "project" ? value : undefined,
        issueKey: ["story", "defect"].includes(type) ? value : undefined,
        sprint: type === "sprint" ? value : type === "backlog" ? null : undefined,
      }, domain, email, apiToken, stream);

      if (success) {
        stream.markdown(`‚úÖ Context \`${type}\` set to \`${value}\``);
      }
      return;
    }

    if (firstWord === "clear-context") {
      await clearUserContext(context);
      stream.markdown("üßπ Jira context cleared.");
      return;
    }

    if (firstWord === "show-context") {
      const markdown = formatUserContextMarkdown(userContext);
      stream.markdown(markdown);
      return;
    }

    const knownCommands = [
      "get",
      "comment",
      "update-summary",
      "update-field",
      "create-subtask",
      "generate-files",
      "create-branch",
      "generatefilesandcreatepr",
      "generatefileandcreateprwithapi",
      "update-all-details-in-jira",
      "help"
    ];

    if (knownCommands.includes(firstWord)) {
      await handleJiraCommand(firstWord, parts.slice(1), {
        currentIssueKey: userContext.issueKey || null,
        domain,
        email,
        apiToken,
        context: chatContext,
        stream,
        request,
        token,
      });
      return;
    }

    const contextualPrompt = userContext.issueKey
      ? `${BASE_PROMPT} The current Jira issue in context is ${userContext.issueKey}.`
      : BASE_PROMPT;

    const messages = [
      vscode.LanguageModelChatMessage.User(contextualPrompt),
      ...getAssistantHistory(chatContext),
      vscode.LanguageModelChatMessage.User(userInput),
    ];

    const aiResponse = await request.model.sendRequest(messages, {}, token);
    for await (const chunk of aiResponse.text) {
      stream.markdown(chunk);
    }
  };

  const participant = vscode.chat.createChatParticipant("jiraCopilot", handler);
  context.subscriptions.push(participant);

  context.subscriptions.push(
    vscode.commands.registerCommand("jiraChat.start", () => {
      vscode.window.showInformationMessage("Jira Chat Started!");
    })
  );
}


-----
// context.ts
import * as vscode from "vscode";
import fetch from "node-fetch";

export type JiraContext = {
  issueKey?: string;
  projectKey?: string;
  sprint?: string | null;
};

const CONTEXT_KEY = "jiraContext";

/**
 * Get the stored Jira context.
 */
export function getUserContext(global: vscode.ExtensionContext): JiraContext {
  return global.globalState.get<JiraContext>(CONTEXT_KEY) || {};
}

/**
 * Update the context, with validation via Jira API.
 */
export async function updateUserContext(
  global: vscode.ExtensionContext,
  updates: Partial<JiraContext>,
  domain: string,
  email: string,
  token: string,
  stream: vscode.ChatResponseStream
): Promise<boolean> {
  const current = getUserContext(global);
  const newContext = { ...current };

  try {
    if (updates.projectKey) {
      const response = await fetch(`${domain}/rest/api/3/project/${updates.projectKey}`, {
        headers: {
          Authorization: "Basic " + Buffer.from(`${email}:${token}`).toString("base64"),
          Accept: "application/json",
        },
      });
      if (!response.ok) throw new Error("Project not found");
      newContext.projectKey = updates.projectKey;
    }

    if (updates.issueKey) {
      const response = await fetch(`${domain}/rest/api/3/issue/${updates.issueKey}`, {
        headers: {
          Authorization: "Basic " + Buffer.from(`${email}:${token}`).toString("base64"),
          Accept: "application/json",
        },
      });
      if (!response.ok) throw new Error("Issue not found");
      newContext.issueKey = updates.issueKey;
    }

    if (updates.sprint !== undefined) {
      newContext.sprint = updates.sprint;
    }

    await global.globalState.update(CONTEXT_KEY, newContext);
    return true;
  } catch (error: any) {
    stream.markdown(`‚ùå ${error.message}`);
    return false;
  }
}

/**
 * Clear all context keys.
 */
export async function clearUserContext(global: vscode.ExtensionContext): Promise<void> {
  await global.globalState.update(CONTEXT_KEY, {});
}

/**
 * Format context as markdown.
 */
export function formatUserContextMarkdown(ctx: JiraContext): string {
  return `### üìå Current Context
- **Project**: \`${ctx.projectKey || "Not set"}\`
- **Issue**: \`${ctx.issueKey || "Not set"}\`
- **Sprint**: \`${ctx.sprint ?? "Not set"}\``;
}

-----

// context.ts
import * as vscode from "vscode";
import {
  jiraGetProject,
  jiraGetIssue
} from "./jiraintegration";

export type JiraContext = {
  issueKey?: string;
  projectKey?: string;
  sprint?: string | null;
};

const CONTEXT_KEY = "jiraContext";

export function getUserContext(global: vscode.ExtensionContext): JiraContext {
  return global.globalState.get<JiraContext>(CONTEXT_KEY) || {};
}

export async function updateUserContext(
  global: vscode.ExtensionContext,
  updates: Partial<JiraContext>,
  domain: string,
  email: string,
  token: string,
  stream: vscode.ChatResponseStream
): Promise<boolean> {
  const current = getUserContext(global);
  const newContext = { ...current };

  try {
    if (updates.projectKey) {
      await jiraGetProject(domain, email, token, updates.projectKey);
      newContext.projectKey = updates.projectKey;
    }

    if (updates.issueKey) {
      await jiraGetIssue(domain, email, token, updates.issueKey);
      newContext.issueKey = updates.issueKey;
    }

    if (updates.sprint !== undefined) {
      newContext.sprint = updates.sprint;
    }

    await global.globalState.update(CONTEXT_KEY, newContext);
    return true;
  } catch (error: any) {
    stream.markdown(`‚ùå ${error.message}`);
    return false;
  }
}

export async function showContextDetails(
  global: vscode.ExtensionContext,
  domain: string,
  email: string,
  token: string,
  stream: vscode.ChatResponseStream
): Promise<void> {
  const context = getUserContext(global);
  if (!context.issueKey) {
    stream.markdown("‚ùó No Jira issue is set. Use `set-context story <ISSUE-KEY>` first.");
    return;
  }

  try {
    const issue = await jiraGetIssue(domain, email, token, context.issueKey);
    const summary = issue.fields.summary;
    const status = issue.fields.status.name;
    const description = issue.fields.description?.content?.[0]?.content?.[0]?.text || "_No description_";

    stream.markdown(`### üßæ ${issue.key}: ${summary}

**Status:** ${status}

**Description:**
${description}`);
  } catch (err: any) {
    stream.markdown(`‚ùå Failed to retrieve context issue: ${err.message}`);
  }
}

export async function clearUserContext(global: vscode.ExtensionContext): Promise<void> {
  await global.globalState.update(CONTEXT_KEY, {});
}

export function formatUserContextMarkdown(ctx: JiraContext): string {
  return `### üìå Current Context
- **Project**: \`${ctx.projectKey || "Not set"}\`
- **Issue**: \`${ctx.issueKey || "Not set"}\`
- **Sprint**: \`${ctx.sprint ?? "Not set"}\``;
}
------- jira -- integration.ts
// jiraintegration.ts
import fetch from "node-fetch";

export async function jiraRequest(
  method: "GET" | "POST" | "PUT",
  domain: string,
  email: string,
  token: string,
  endpoint: string,
  body?: any
): Promise<any> {
  const headers: Record<string, string> = {
    Authorization: "Basic " + Buffer.from(`${email}:${token}`).toString("base64"),
    Accept: "application/json",
  };

  if (method === "POST" || method === "PUT") {
    headers["Content-Type"] = "application/json";
  }

  const res = await fetch(`${domain}${endpoint}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });

  if (!res.ok) {
    const errorText = await res.text();
    throw new Error(`Jira API ${method} ${endpoint} failed: ${res.status} - ${errorText}`);
  }

  return await res.json();
}

export async function jiraGetProject(
  domain: string,
  email: string,
  token: string,
  projectKey: string
) {
  return await jiraRequest("GET", domain, email, token, `/rest/api/3/project/${projectKey}`);
}

export async function jiraGetIssue(
  domain: string,
  email: string,
  token: string,
  issueKey: string
) {
  return await jiraRequest("GET", domain, email, token, `/rest/api/3/issue/${issueKey}`);
}

export async function jiraUpdateIssueFields(
  domain: string,
  email: string,
  token: string,
  issueKey: string,
  fields: Record<string, any>
) {
  return await jiraRequest("PUT", domain, email, token, `/rest/api/3/issue/${issueKey}`, {
    fields,
  });
}

export async function jiraAddComment(
  domain: string,
  email: string,
  token: string,
  issueKey: string,
  comment: string
) {
  const body = {
    body: {
      type: "doc",
      version: 1,
      content: [
        {
          type: "paragraph",
          content: [{ type: "text", text: comment }],
        },
      ],
    },
  };

  return await jiraRequest(
    "POST",
    domain,
    email,
    token,
    `/rest/api/3/issue/${issueKey}/comment`,
    body
  );
}

export async function jiraCreateSubtask(
  domain: string,
  email: string,
  token: string,
  parentKey: string,
  summary: string,
  description?: string
) {
  const projectKey = parentKey.split("-")[0];
  const fields: Record<string, any> = {
    summary,
    parent: { key: parentKey },
    project: { key: projectKey },
    issuetype: { name: "Sub-task" },
  };

  if (description) {
    fields.description = {
      type: "doc",
      version: 1,
      content: [
        {
          type: "paragraph",
          content: [{ type: "text", text: description }],
        },
      ],
    };
  }

  return await jiraRequest("POST", domain, email, token, "/rest/api/3/issue", { fields });
}

export async function jiraCreateIssue(
  domain: string,
  email: string,
  token: string,
  projectKey: string,
  issueType: string,
  summary: string,
  description?: string
) {
  const fields: Record<string, any> = {
    summary,
    issuetype: { name: issueType },
    project: { key: projectKey },
  };

  if (description) {
    fields.description = {
      type: "doc",
      version: 1,
      content: [
        {
          type: "paragraph",
          content: [{ type: "text", text: description }],
        },
      ],
    };
  }

  return await jiraRequest("POST", domain, email, token, "/rest/api/3/issue", { fields });
}

----------
// extension.ts
import * as vscode from "vscode";
import fetch from "node-fetch";
import * as path from "path";
import * as fs from "fs";
import {
  getUserContext,
  updateUserContext,
  clearUserContext,
  formatUserContextMarkdown,
  showContextDetails,
} from "./context";

const BASE_PROMPT =
  "You are a helpful Jira assistant. You can retrieve, comment on, update, and create Jira issues. Be concise and return markdown-formatted responses.";

let currentIssueKey: string | null = null;
const output = vscode.window.createOutputChannel("Jira Extension Logs");

export function activate(context: vscode.ExtensionContext) {
  const handler: vscode.ChatRequestHandler = async (
    request,
    chatContext,
    stream,
    token
  ) => {
    const config = vscode.workspace.getConfiguration();
    const domain = config.get<string>("jiraChat.domain");
    const email = config.get<string>("jiraChat.email");
    const apiToken = config.get<string>("jiraChat.apiToken");

    if (!domain || !email || !apiToken) {
      stream.markdown("‚ùå Please configure Jira credentials in settings (`jiraChat.*`).");
      return;
    }

    const userInput = request.prompt.trim();
    const parts = userInput.split(" ").map((p) => p.trim());
    const firstWord = parts[0]?.toLowerCase();

    // Enforce set-context before other commands
    const userContext = getUserContext(context);
    if (
      !["set-context", "clear-context", "show-context", "get-context-details"].includes(firstWord) &&
      !userContext?.issueKey
    ) {
      stream.markdown("‚ùó Please set context first using `set-context [story|defect] <ISSUE-KEY>`.");
      return;
    }

    if (firstWord === "set-context") {
      const [_, type, ...rest] = parts;
      const value = rest.join(" ").trim().toUpperCase();
      if (!type || !value) {
        stream.markdown("‚ùó Usage: `set-context [project|story|defect|sprint|backlog] <value>`");
        return;
      }

      const success = await updateUserContext(context, {
        projectKey: type === "project" ? value : undefined,
        issueKey: ["story", "defect"].includes(type) ? value : undefined,
        sprint: type === "sprint" ? value : type === "backlog" ? null : undefined,
      }, domain, email, apiToken, stream);

      if (success) {
        stream.markdown(`‚úÖ Context \`${type}\` set to \`${value}\``);
      }
      return;
    }

    if (firstWord === "clear-context") {
      await clearUserContext(context);
      stream.markdown("üßπ Jira context cleared.");
      return;
    }

    if (firstWord === "show-context") {
      const markdown = formatUserContextMarkdown(userContext);
      stream.markdown(markdown);
      return;
    }

    if (firstWord === "get-context-details") {
      await showContextDetails(context, domain, email, apiToken, stream);
      return;
    }

    const knownCommands = [
      "get",
      "comment",
      "update-summary",
      "update-field",
      "create-subtask",
      "generate-files",
      "create-branch",
      "generatefilesandcreatepr",
      "generatefileandcreateprwithapi",
      "update-all-details-in-jira",
      "help"
    ];

    if (knownCommands.includes(firstWord)) {
      await handleJiraCommand(firstWord, parts.slice(1), {
        currentIssueKey: userContext.issueKey || null,
        domain,
        email,
        apiToken,
        context: chatContext,
        stream,
        request,
        token,
      });
      return;
    }

    const contextualPrompt = userContext.issueKey
      ? `${BASE_PROMPT} The current Jira issue in context is ${userContext.issueKey}.`
      : BASE_PROMPT;

    const messages = [
      vscode.LanguageModelChatMessage.User(contextualPrompt),
      ...getAssistantHistory(chatContext),
      vscode.LanguageModelChatMessage.User(userInput),
    ];

    const aiResponse = await request.model.sendRequest(messages, {}, token);
    for await (const chunk of aiResponse.text) {
      stream.markdown(chunk);
    }
  };

  const participant = vscode.chat.createChatParticipant("jiraCopilot", handler);
  context.subscriptions.push(participant);

  context.subscriptions.push(
    vscode.commands.registerCommand("jiraChat.start", () => {
      vscode.window.showInformationMessage("Jira Chat Started!");
    })
  );
}

